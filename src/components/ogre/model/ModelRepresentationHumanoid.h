/*
 Copyright (C) 2014 Céline NOËL <celine.noel.7294@gmail.com>

 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 2 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#ifndef MODELREPRESENTATIONHUMANOID_H_
#define MODELREPRESENTATIONHUMANOID_H_

#include "ModelRepresentation.h"


namespace Ember
{
class SmartBodyManager;
class SmartBodyRepresentation;

namespace OgreView
{
class Scene;

namespace Model
{

class ActionDefinition;
struct SoundDefinition;
class Model;

/**
 @brief A model representation that is specialized for humanoid character.

 The common animations (locomotion, gestures, ...) are generated by SmartBody library.

 @author Céline NOEL <celine.noel.7294@gmail.com>

 */
class ModelRepresentationHumanoid: public ModelRepresentation
{
public:

	/**
	 * @brief Ctor.
	 * @param entity The entity instance to bind to.
	 * @param model The model instance used.
	 * @param scene The scene to which the entity belongs.
	 * @param mapping The model mapping tied to the model.
	 * @param sbManager A pointer to the SmartBody Manager.
	 */
	ModelRepresentationHumanoid(EmberEntity& entity, Model& model, Scene& scene, EntityMapping::EntityMapping& mapping, SmartBodyManager& sbManager);

	/**
	 * @brief Dtor.
	 */
	virtual ~ModelRepresentationHumanoid();

	/**
	 * @brief The two following return the name of this class.
	 */
	const std::string& getType() const;
	static const std::string& getTypeNameForClass();

	/**
	 * @return false if the model is animated manually with SmartBody, true otherwise.
	 */
	bool isOgreAnimated() const;
	
	/**
	 * @brief States that the character is moving, to know if we need to update the position of the scene node (for example, if the
	 * character is in the idling posture, the position should not be updated, but in the case of a humanoid character, the translation 
	 * from walking to idling posture is not instantaneous, so we have to update it as long as the model is not entirely still).
	 */
	bool isMoving() const;

	/**
	 * @brief Returns true if the character's posture is static.
	 */
	bool isStatic() const;

	/**
	 * @brief Sets the position and orientation of the character in the world (updates mCharacter). 
	 */
	void updateServerPositionAndOrientation(const Ogre::Vector3& position, const Ogre::Quaternion& orientation);

	/**
	 * @brief Returns the position and orientation that the character would reasonably have taking in account the server data and SmartBody movements.
	 */
	const Ogre::Vector3& getActualPosition();
	const Ogre::Quaternion& getActualOrientation();
	

protected:

	/**
	 * @brief The corresponding SmartBody character.
	 */
	SmartBodyRepresentation *mCharacter;

	/**
	 * @brief A reference to the SmartBodyManager.
	 */
	SmartBodyManager& mSbManager;

	/**
	 * @brief The type name for the class.
	 */
	static std::string sTypeName;

	/**
	 * @brief Overriden from ModelRepresentation.
	 */
	void setIdleAnimationTime();

	/**
	 * @brief Overrides model_Reloaded_der in ModelRepresentation.
	 */
	void model_Reloaded_der();

	/**
	 * @brief Creates the character representation in SmartBody.
	 */
	void createSmartBodyCharacter();

	/**
	 * @brief Sets the animation corresponding to the given action.
	 */
	void setAnimation(const std::string& actionName, Action *newAction);
};

}
}
}
#endif /* MODELREPRESENTATION_H_ */
